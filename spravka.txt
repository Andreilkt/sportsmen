Для работы с JSON файлами в Python, вам потребуется использовать стандартный модуль `json`. Ниже представлен пример, как считать JSON файл, соединить два поля и записать результат в другой JSON файл.

Предположим, что у вас есть входной JSON файл `input.json` со следующим содержимым:

```json
[
    {"first_name": "John", "last_name": "Doe"},
    {"first_name": "Jane", "last_name": "Smith"}
]
```

Мы хотим соединить поля `first_name` и `last_name` в одно поле `full_name` и записать результат в новый файл `output.json`.

Вот код для выполнения этой задачи:

```python
import json

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: соединяем first_name и last_name
for item in data:
    item['full_name'] = f"{item['first_name']} {item['last_name']}"
    # Удаляем старые поля, если они больше не нужны
    del item['first_name']
    del item['last_name']

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Объяснение кода:
1. **Импортируем модуль json:** Этот модуль позволяет работать с JSON-форматом.
2. **Чтение входного файла:** Открываем `input.json` для чтения и загружаем данные в переменную `data`.
3. **Обработка данных:** Итерируем по каждой записи в `data`, создаем новое поле `full_name`, соединяя `first_name` и `last_name`, и удаляем старые поля.
4. **Запись результата в выходной файл:** Открываем файл `output.json` для записи и используем `json.dump` для записи данных. Параметр `ensure_ascii=False` используется для корректного отображения символов, а `indent=4` делает вывод более читабельным.
5. **Вывод сообщения о завершении:** Сообщаем о том, что операция завершена успешно.

Теперь в файле `output.json` у вас будет следующий результат:

```json
[
    {"full_name": "John Doe"},
    {"full_name": "Jane Smith"}
]
```

Этот код можно модифицировать в зависимости от структуры вашего JSON и требований к выходным данным.






Чтобы вычислить разницу между двумя полями в JSON файле с помощью Python и записать результат в другой JSON файл, вы можете использовать следующий код.

Предположим, у вас есть входной JSON файл `input.json`, содержащий следующий массив объектов, где вы хотите найти разницу между полями `value1` и `value2`:

```json
[
    {"value1": 10, "value2": 5},
    {"value1": 20, "value2": 15},
    {"value1": 30, "value2": 25}
]
```

Мы хотим вычислить разницу (то есть `value1 - value2`) и сохранить результат в новое поле `difference` в новом файле `output.json`.

### Вот пример кода:

```python
import json

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: вычисляем разницу между value1 и value2
for item in data:
    if 'value1' in item and 'value2' in item:
        item['difference'] = item['value1'] - item['value2']
        # Удаляем старые поля, если они больше не нужны (необязательно)
        # del item['value1']
        # del item['value2']

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Объяснение кода:
1. **Импортируем модуль json:** Модуль позволяет работать с JSON-форматом.
2. **Чтение входного файла:** Открываем файл `input.json` и загружаем данные в переменную `data`.
3. **Обработка данных:** Итерируем по каждому элементу `data`, проверяем, существуют ли поля `value1` и `value2`, и вычисляем их разницу, записывая результат в новое поле `difference`.
   - Если вы хотите сохранить только новое поле `difference`, вы можете раскомментировать строки `del item['value1']` и `del item['value2']`.
4. **Запись результата в выходной файл:** Открываем файл `output.json` для записи и используем `json.dump` для записи данных с параметрами `ensure_ascii=False` и `indent=4` для удобочитаемого формата.
5. **Вывод сообщения о завершении:** Сообщаем, что операция завершена успешно.

### Результат:
После выполнения вышеуказанного кода, в файле `output.json` будет следующий результат:

```json
[
    {"value1": 10, "value2": 5, "difference": 5},
    {"value1": 20, "value2": 15, "difference": 5},
    {"value1": 30, "value2": 25, "difference": 5}
]
```

Теперь у вас есть новый JSON файл, содержащий разницу между `value1` и `value2` для каждого объекта. Вы можете модифицировать структуру и поля в соответствии с вашими требованиями.




Ошибка `unsupported operand type(s) for -: 'str' and 'str'` возникает, когда вы пытаетесь вычесть одно строковое значение из другого. Это может происходить, если поля `value1` и `value2` в ваших данных на самом деле имеют тип строк (`str`), а не числовой тип (`int` или `float`).

Чтобы решить эту проблему, необходимо убедиться, что поля `value1` и `value2` содержат числовые значения перед выполнением операции вычитания. Вы можете сделать это, преобразовав их в целые числа или числа с плавающей запятой с помощью функции `int()` или `float()`.

Вот исправленный пример кода, который выполняет такое преобразование:

```python
import json

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: вычисляем разницу между value1 и value2
for item in data:
    if 'value1' in item and 'value2' in item:
        try:
            # Преобразуем строки в числа
            value1 = float(item['value1'])
            value2 = float(item['value2'])
            item['difference'] = value1 - value2
        except ValueError:
            print(f"Ошибка преобразования: '{item['value1']}' или '{item['value2']}' не является числом.")

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Что изменилось в этом коде:
1. **Преобразование типов:** Теперь перед вычитанием мы преобразуем `value1` и `value2` в числа с плавающей запятой с помощью `float()`. Это позволит избежать ошибки, если изначально данные представлены в виде строк.
2. **Обработка ошибок:** Добавлен блок `try-except`, чтобы ловить возможные ошибки преобразования. Если строковые значения не могут быть преобразованы в числа, выведется сообщение об ошибке, но программа продолжит выполнение.

### Рекомендации:
- Убедитесь, что в вашем исходном файле `input.json` значения в полях `value1` и `value2` действительно могут быть представлены как числа.
- Если хотите работать только с целыми числами, замените `float()` на `int()`, но учтите, что любое дробное число будет отброшено, а не округлено.

Теперь код должен работать без ошибок, если значения в полях определяются корректно.

Если ваши поля в JSON имеют названия, состоящие из нескольких слов, и вы хотите объединить их в одно слово (например, `'Время финиша'` и `'Время старта'` в `ВремяФиниша` и `ВремяСтарта`), вы можете сделать это, используя метод строки `replace()` для удаления пробелов или просто заменив их на нужный символ.

Вот пример, который демонстрирует, как это сделать:

### Исходный JSON файл (`input.json`):
```json
[
    {"Время финиша": "2023-10-01 12:00", "Время старта": "2023-10-01 10:00"},
    {"Время финиша": "2023-10-02 15:00", "Время старта": "2023-10-02 14:00"}
]
```

### Пример кода:
```python
import json

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: заменяем пробелы в названиях полей
for item in data:
    if 'Время финиша' in item and 'Время старта' in item:
        # Соединяем названия полей
        item['ВремяФиниша'] = item.pop('Время финиша')
        item['ВремяСтарта'] = item.pop('Время старта')

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Объяснение кода:
1. **Чтение входного файла:** Открываем `input.json` и загружаем данные.
2. **Обработка данных:** Проходим по каждому элементу в списке. Если поля `'Время финиша'` и `'Время старта'` существуют, мы создаем новые поля:
   - `item['ВремяФиниша']` получает значение из `item.pop('Время финиша')`.
   - `item['ВремяСтарта']` получает значение из `item.pop('Время старта')`.
   - Метод `pop()` удаляет старые поля из идентификатора и возвращает их значение. Это позволяет сделать код более «чистым», так как старые поля автоматически удаляются.
3. **Запись результата в выходной файл:** Записываем измененные данные в `output.json`.

### Результат:
После выполнения кода, файл `output.json` будет выглядеть следующим образом:

```json
[
    {"ВремяФиниша": "2023-10-01 12:00", "ВремяСтарта": "2023-10-01 10:00"},
    {"ВремяФиниша": "2023-10-02 15:00", "ВремяСтарта": "2023-10-02 14:00"}
]
```

Теперь названия ваших полей объединены в одно слово, и результат записан в новый JSON файл.


Конечно! Ниже представлен полный код, который считывает JSON файл с двумя полями с пробелами в названиях, вычисляет разницу между значениями, которые могут быть в строковом формате, объединяет названия полей и записывает результат в новый JSON файл.

### Пример исходного JSON файла (`input.json`):
```json
[
    {"Время финиша": "2023-10-01 12:00", "Время старта": "2023-10-01 10:00"},
    {"Время финиша": "2023-10-02 15:00", "Время старта": "2023-10-02 14:00"},
    {"Время финиша": "2023-10-03 18:30", "Время старта": "2023-10-03 17:00"}
]
```

### Полный код для обработки данных:
```python
import json
from datetime import datetime

# Функция для вычисления разницы во времени
def calculate_time_difference(end_time_str, start_time_str):
    end_time = datetime.strptime(end_time_str, "%Y-%m-%d %H:%M")
    start_time = datetime.strptime(start_time_str, "%Y-%m-%d %H:%M")
    difference = end_time - start_time
    return difference.total_seconds() / 60  # Возвращаем разницу в минутах

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: вычисляем разницу между 'Время финиша' и 'Время старта'
for item in data:
    if 'Время финиша' in item and 'Время старта' in item:
        # Вычисляем разницу во времени
        time_difference = calculate_time_difference(item['Время финиша'], item['Время старта'])

        # Создаем новые поля без пробелов
        item['ВремяФиниша'] = item.pop('Время финиша')
        item['ВремяСтарта'] = item.pop('Время старта')
        item['Разница (мин)'] = time_difference  # Сохраняем разницу в минутах

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Объяснение кода:
1. **Импорт библиотек:**
    - `json`: для работы с JSON файлами.
    - `datetime`: для работы с временными данными и расчетами между ними.

2. **Функция `calculate_time_difference`:**
    - Принимает два строковых параметра, представляющих время финиша и старта.
    - Использует `datetime.strptime()` для преобразования строк в объекты `datetime`.
    - Вычисляет разницу во времени и возвращает её в минутах.

3. **Чтение входного файла:**
    - Открываем и загружаем JSON данные из `input.json`.

4. **Обработка данных:**
    - Проходим по каждому элементу в `data`.
    - Проверяем наличие полей `'Время финиша'` и `'Время старта'`.
    - Вычисляем разницу во времени и создаем новые поля с именами без пробелов.
    - Используем `item.pop()` для удаления старых полей, сохраняя их значения.

5. **Запись нового файла:**
    - Записываем обработанные данные в `output.json` в формате JSON с отступами для удобочитаемости.

6. **Вывод информации:**
    - Печатаем сообщение о том, что данные успешно обработаны и записаны.

### Результат:
После выполнения кода, файл `output.json` будет выглядеть следующим образом:

```json
[
    {
        "ВремяФиниша": "2023-10-01 12:00",
        "ВремяСтарта": "2023-10-01 10:00",
        "Разница (мин)": 120.0
    },
    {
        "ВремяФиниша": "2023-10-02 15:00",
        "ВремяСтарта": "2023-10-02 14:00",
        "Разница (мин)": 60.0
    },
    {
        "ВремяФиниша": "2023-10-03 18:30",
        "ВремяСтарта": "2023-10-03 17:00",
        "Разница (мин)": 90.0
    }
]
```

Этот код корректно обрабатывает данные, присоединяет названия полей и вычисляет разницу во времени в минутах.

Если ваши данные о времени старта и финиша представлены в формате `ЧЧ:ММ:СС`, вы можете внести небольшие изменения в код, чтобы корректно обрабатывать это время. Например, мы можем использовать только часы, минуты и секунды для вычисления разницы во времени.

Вот как вы можете модифицировать код:

### Пример исходного JSON файла (`input.json`):
```json
[
    {"Время финиша": "12:18:31", "Время старта": "06:47:34"},
    {"Время финиша": "14:45:00", "Время старта": "14:00:00"},
    {"Время финиша": "18:30:00", "Время старта": "17:10:00"}
]
```

### Полный код для обработки данных:
```python
import json
from datetime import datetime

# Функция для вычисления разницы во времени
def calculate_time_difference(end_time_str, start_time_str):
    # Преобразуем строки формата ЧЧ:ММ:СС в объекты datetime
    end_time = datetime.strptime(end_time_str, "%H:%M:%S")
    start_time = datetime.strptime(start_time_str, "%H:%M:%S")
    # Разница во времени
    difference = end_time - start_time
    return difference.total_seconds() / 60  # Возвращаем разницу в минутах

# Чтение данных из input.json
with open('input.json', 'r', encoding='utf-8') as infile:
    data = json.load(infile)

# Обработка данных: вычисляем разницу между 'Время финиша' и 'Время старта'
for item in data:
    if 'Время финиша' in item and 'Время старта' in item:
        # Вычисляем разницу во времени
        time_difference = calculate_time_difference(item['Время финиша'], item['Время старта'])

        # Создаем новые поля без пробелов
        item['ВремяФиниша'] = item.pop('Время финиша')
        item['ВремяСтарта'] = item.pop('Время старта')
        item['Разница (мин)'] = time_difference  # Сохраняем разницу в минутах

# Запись результата в output.json
with open('output.json', 'w', encoding='utf-8') as outfile:
    json.dump(data, outfile, ensure_ascii=False, indent=4)

print("Данные успешно обработаны и записаны в output.json")
```

### Объяснение изменений:
1. **Функция `calculate_time_difference`:**
   - Мы используем `datetime.strptime()` с форматом `"%H:%M:%S"`, так как время представлено в формате часов, минут и секунд.
   - Разница во времени вычисляется как разница между двумя объектами `datetime`, и возвращаем различие в минутах.

2. **Обработка данных остается аналогичной:**
   - Мы проверяем, существуют ли поля `'Время финиша'` и `'Время старта'`.
   - Вычисляем разницу во времени, присоединяем новые поля и удаляем старые.

### Результат:
После выполнения этого кода из приведенного примера JSON, файл `output.json` будет выглядеть следующим образом:

```json
[
    {
        "ВремяФиниша": "12:18:31",
        "ВремяСтарта": "06:47:34",
        "Разница (мин)": 291.1166666666667
    },
    {
        "ВремяФиниша": "14:45:00",
        "ВремяСтарта": "14:00:00",
        "Разница (мин)": 45.0
    },
    {
        "ВремяФиниша": "18:30:00",
        "ВремяСтарта": "17:10:00",
        "Разница (мин)": 80.0
    }
]
```

Теперь вы получаете разницу между временем старта и финиша в минутах, и код работает с корректным форматом времени. Если время финиша оказывается раньше времени старта, разница будет отрицательной; в этом случае вы можете добавить дополнительную логику для обработки таких случаев, если это необходимо.

Для того чтобы считывать данные из нескольких JSON файлов, извлекать определенные данные и записывать их в новые файлы с названиями, основанными на значениях полей, можно использовать следующий подход:

1. Считать данные из всех трех файлов JSON.
2. Извлечь нужные данные из этих файлов.
3. На основе нужного поля создать названия новых файлов.
4. Записать данные в новые файлы.

Вот пример кода, который демонстрирует этот процесс.

### Предположим, у вас есть три входных файла:

1. **file1.json**
    ```json
    [
        {"name": "Alice", "age": 30, "city": "New York"},
        {"name": "Bob", "age": 25, "city": "Los Angeles"}
    ]
    ```

2. **file2.json**
    ```json
    [
        {"name": "Charlie", "age": 35, "city": "Chicago"},
        {"name": "David", "age": 28, "city": "San Francisco"}
    ]
    ```

3. **file3.json**
    ```json
    [
        {"name": "Eve", "age": 22, "city": "Miami"},
        {"name": "Frank", "age": 40, "city": "Houston"}
    ]
    ```

### Пример кода для обработки данных:

```python
import json

# Функция для считывания данных из JSON файла
def read_json_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as infile:
        return json.load(infile)

# Функция для записи данных в новый JSON файл
def write_json_file(data, file_path):
    with open(file_path, 'w', encoding='utf-8') as outfile:
        json.dump(data, outfile, ensure_ascii=False, indent=4)

# Считываем данные из трех файлов
data1 = read_json_file('file1.json')
data2 = read_json_file('file2.json')
data3 = read_json_file('file3.json')

# Объединяем данные в один список
all_data = data1 + data2 + data3

# Создаём новые файлы на основе значения поля 'name'
for item in all_data:
    # Генерируем имя нового файла
    new_file_name = f"{item['name']}.json"

    # Записываем текущий элемент в новый файл
    write_json_file([item], new_file_name)

print("Данные успешно обработаны и записаны в новые файлы JSON.")
```

### Объяснение кода:
1. **Функция `read_json_file`:** Считывает данные из указанного JSON файла и возвращает их.
2. **Функция `write_json_file`:** Записывает данные в указанный JSON файл.
3. **Считываем данные из трех файлов:** Загружаем данные из `file1.json`, `file2.json` и `file3.json`, и объединяем их в один список `all_data`.
4. **Создание новых файлов:**
    - Обходим каждый элемент в объединенных данных.
    - Генерируем имя нового файла на основе значения поля `name` (например, для объекта с `name` равным "Alice" создастся файл с именем `Alice.json`).
    - Записываем текущий элемент в новый файл, используя `write_json_file`.

### Результат:
После выполнения этого кода у вас в текущей директории возникнут новые файлы:

- `Alice.json`:
    ```json
    [{"name": "Alice", "age": 30, "city": "New York"}]
    ```

- `Bob.json`:
    ```json
    [{"name": "Bob", "age": 25, "city": "Los Angeles"}]
    ```

- `Charlie.json`:
    ```json
    [{"name": "Charlie", "age": 35, "city": "Chicago"}]
    ```

- И так далее для других имен.

### Примечания:
- Убедитесь, что имена файлов, созданные на основе значений полей, являются допустимыми для файловой системы. Это означает, что в них не должно быть символов, недопустимых для имен файлов (например, `\/:*?"<>|`).
- Если в данных есть дубликаты имен, в результате будут перезаписаны файлы. Чтобы избежать этого, можно добавить суффиксы или использовать уникальные идентификаторы.






Вы можете выполнить следующие шаги, чтобы считать данные из одного JSON файла, затем считать данные из трех текстовых файлов, извлечь нужные данные и записать все в один JSON файл, название которого будет основано на значении одного из полей из выбранного JSON.

### Пример

#### 1. Исходный JSON файл (`data.json`):
Допустим, у вас есть JSON файл `data.json` следующего содержания:

```json
[
    {"name": "Alice", "age": 30, "city": "New York"},
    {"name": "Bob", "age": 25, "city": "Los Angeles"}
]
```

#### 2. Текстовые файлы:
У вас есть три текстовых файла, каждый из которых содержит по одной строке:

- **file1.txt**
    ```
    Hobbies: Reading, Traveling
    ```

- **file2.txt**
    ```
    Favorite Food: Pizza
    ```

- **file3.txt**
    ```
    Job: Engineer
    ```

### Пример кода для обработки данных:
Этот код считывает данные из JSON файла, извлекает нужные поля, а затем считывает данные из текстовых файлов и записывает все в новый JSON файл.

```python
import json

# Функция для считывания данных из JSON файла
def read_json_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as infile:
        return json.load(infile)

# Функция для считывания данных из текстового файла
def read_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as infile:
        return infile.read().strip()  # Удаляем лишние пробелы и символы новой строки


# Выбираем нужное поле (например, 'name' из первого объекта)
chosen_name = json_data[0]['name']  # Здесь можно изменить индекс для выбора другого объекта

# Создаем словарь для записи данных
combined_data = {
    "name": chosen_name,
    "additional_info": []
}

# Считываем строки из текстовых файлов и добавляем их в 'additional_info'
for file in ['file1.txt', 'file2.txt', 'file3.txt']:
    info = read_text_file(file)
    combined_data['additional_info'].append(info)

# Название выходного файла основано на выбранном поле
output_filename = f"{chosen_name}.json"

# Записываем все данные в новый JSON файл
with open(output_filename, 'w', encoding='utf-8') as outfile:
    json.dump(combined_data, outfile, ensure_ascii=False, indent=4)

print(f"Данные успешно обработаны и записаны в файл: {output_filename}")
```

### Объяснение кода:
1. **Функция `read_json_file`:** Считывает данные из указанного JSON файла.
2. **Функция `read_text_file`:** Считывает данные из указанного текстового файла и возвращает их в виде строки, удаляя лишние пробелы.
3. **Считывание данных из `data.json`:** Данные загружаются в переменную `json_data`.
4. **Выбор нужного поля:** Извлекаем имя из первого объекта (вы можете легко изменить индекс, чтобы выбрать имя из другого объекта).
5. **Подготовка комбинированных данных:** Создаем словарь `combined_data`, который будет содержать выбранное поле и дополнительную информацию из текстовых файлов.
6. **Считывание и добавление данных из текстовых файлов:** Считываются содержимое трех текстовых файлов, и каждое содержание добавляется в список под ключом `additional_info`.
7. **Формирование имени выходного файла:** Имя выходного файла формируется из выбранного имени.
8. **Запись комбинированных данных в новый JSON файл:** Данные сохраняются в новый файл на диске.

### Результат:
После выполнения этого кода у вас будет создан файл, например, `Alice.json`, который будет содержать следующее:

```json
{
    "name": "Alice",
    "additional_info": [
        "Hobbies: Reading, Traveling",
        "Favorite Food: Pizza",
        "Job: Engineer"
    ]
}
```

Вы можете изменить индекс в `chosen_name = json_data[0]['name']`, чтобы извлечь различные данные из JSON файла или выбрать другие поля по мере необходимости.




Вы можете выполнить следующие шаги, чтобы считать данные из одного JSON файла, затем считать данные из трех текстовых файлов, извлечь нужные данные и записать все в один JSON файл, название которого будет основано на значении одного из полей из выбранного JSON.

### Пример

#### 1. Исходный JSON файл (`data.json`):
Допустим, у вас есть JSON файл `data.json` следующего содержания:

```json
[
    {"name": "Alice", "age": 30, "city": "New York"},
    {"name": "Bob", "age": 25, "city": "Los Angeles"}
]
```

#### 2. Текстовые файлы:
У вас есть три текстовых файла, каждый из которых содержит по одной строке:

- **file1.txt**
    ```
    Hobbies: Reading, Traveling
    ```

- **file2.txt**
    ```
    Favorite Food: Pizza
    ```

- **file3.txt**
    ```
    Job: Engineer
    ```

### Пример кода для обработки данных:
Этот код считывает данные из JSON файла, извлекает нужные поля, а затем считывает данные из текстовых файлов и записывает все в новый JSON файл.

```python
import json

# Функция для считывания данных из JSON файла
def read_json_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as infile:
        return json.load(infile)

# Функция для считывания данных из текстового файла
def read_text_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as infile:
        return infile.read().strip()  # Удаляем лишние пробелы и символы новой строки

# Считываем данные из JSON файла
json_data = read_json_file('data.json')

# Выбираем нужное поле (например, 'name' из первого объекта)
chosen_name = json_data[0]['name']  # Здесь можно изменить индекс для выбора другого объекта

# Создаем словарь для записи данных
combined_data = {
    "name": chosen_name,
    "additional_info": []
}

# Считываем строки из текстовых файлов и добавляем их в 'additional_info'
for file in ['file1.txt', 'file2.txt', 'file3.txt']:
    info = read_text_file(file)
    combined_data['additional_info'].append(info)

# Название выходного файла основано на выбранном поле
output_filename = f"{chosen_name}.json"

# Записываем все данные в новый JSON файл
with open(output_filename, 'w', encoding='utf-8') as outfile:
    json.dump(combined_data, outfile, ensure_ascii=False, indent=4)

print(f"Данные успешно обработаны и записаны в файл: {output_filename}")
```

### Объяснение кода:
1. **Функция `read_json_file`:** Считывает данные из указанного JSON файла.
2. **Функция `read_text_file`:** Считывает данные из указанного текстового файла и возвращает их в виде строки, удаляя лишние пробелы.
3. **Считывание данных из `data.json`:** Данные загружаются в переменную `json_data`.
4. **Выбор нужного поля:** Извлекаем имя из первого объекта (вы можете легко изменить индекс, чтобы выбрать имя из другого объекта).
5. **Подготовка комбинированных данных:** Создаем словарь `combined_data`, который будет содержать выбранное поле и дополнительную информацию из текстовых файлов.
6. **Считывание и добавление данных из текстовых файлов:** Считываются содержимое трех текстовых файлов, и каждое содержание добавляется в список под ключом `additional_info`.
7. **Формирование имени выходного файла:** Имя выходного файла формируется из выбранного имени.
8. **Запись комбинированных данных в новый JSON файл:** Данные сохраняются в новый файл на диске.

### Результат:
После выполнения этого кода у вас будет создан файл, например, `Alice.json`, который будет содержать следующее:

```json
{
    "name": "Alice",
    "additional_info": [
        "Hobbies: Reading, Traveling",
        "Favorite Food: Pizza",
        "Job: Engineer"
    ]
}
```

Вы можете изменить индекс в `chosen_name = json_data[0]['name']`, чтобы извлечь различные данные из JSON файла или выбрать другие поля по мере необходимости.
