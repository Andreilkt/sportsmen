import json

def process_json(input_file, output_file, key_to_match, value_to_match, keys_to_extract):
    """
    Читает JSON из файла, преобразует в список словарей, фильтрует элементы
    по заданному ключу и значению, извлекает определенные ключи из отфильтрованных
    элементов и записывает результат в другой JSON файл.

    Args:
        input_file (str): Путь к входному JSON файлу.
        output_file (str): Путь к выходному JSON файлу.
        key_to_match (str): Ключ, по которому нужно фильтровать элементы.
        value_to_match (any): Значение, которое должно соответствовать ключу для фильтрации.
        keys_to_extract (list): Список ключей, которые нужно извлечь из отфильтрованных элементов.
    """

    try:
        with open(input_file, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Ошибка: Файл '{input_file}' не найден.")
        return
    except json.JSONDecodeError:
        print(f"Ошибка: Файл '{input_file}' содержит некорректный JSON.")
        return

    if not isinstance(data, list):
        print("Ошибка: Входной JSON файл должен содержать список.")
        return

    # Фильтрация и извлечение данных
    filtered_data = []
    for item in data:
        if isinstance(item, dict) and key_to_match in item and item[key_to_match] == value_to_match:
            extracted_item = {key: item.get(key) for key in keys_to_extract}  # .get() чтобы избежать KeyError
            filtered_data.append(extracted_item)

    # Запись в выходной файл
    try:
        with open(output_file, 'w') as f:
            json.dump(filtered_data, f, indent=4, ensure_ascii=False)
        print(f"Данные успешно записаны в файл '{output_file}'.")
    except Exception as e:
        print(f"Ошибка при записи в файл '{output_file}': {e}")
        return


# Пример использования:

# 1. Создадим пример json файл (input.json)
#    Содержимое:
#    [
#        {"id": 1, "name": "Alice", "city": "New York", "age": 30},
#        {"id": 2, "name": "Bob", "city": "London", "age": 25},
#        {"id": 3, "name": "Charlie", "city": "New York", "age": 35},
#        {"id": 4, "name": "David", "city": "Paris", "age": 40}
#    ]

# 2. Вызываем функцию:
input_file = 'input.json'
output_file = 'output.json'
key_to_match = 'city'
value_to_match = 'New York'
keys_to_extract = ['id', 'name', 'age']

process_json(input_file, output_file, key_to_match, value_to_match, keys_to_extract)


# Результат (output.json):
# [
#     {
#         "id": 1,
#         "name": "Alice",
#         "age": 30
#     },
#     {
#         "id": 3,
#         "name": "Charlie",
#         "age": 35
#     }
# ]




# Ключевые улучшения и объяснения:
#
# • Обработка ошибок: Добавлены блоки try...except для обработки возможных ошибок:
#   * FileNotFoundError: Если входной файл не существует.
#   * json.JSONDecodeError: Если входной файл содержит некорректный JSON.
#   * Общая обработка исключений при записи в файл, чтобы поймать любые другие ошибки записи.
# • Проверка типа данных: Проверяется, что загруженные данные являются списком (isinstance(data, list)), как и ожидается.
# • Безопасное извлечение ключей: Используется item.get(key) вместо item[key] для извлечения значений. Это предотвращает возникновение KeyError, если ключ отсутствует в элементе словаря. item.get(key) вернет None, если ключ не найден, что более безопасно.
# • Гибкость: Функция принимает в качестве аргументов пути к входному и выходному файлам, ключ и значение для фильтрации, а также список ключей для извлечения. Это делает функцию универсальной для различных сценариев.
# • Читаемость: Код отформатирован для лучшей читаемости, с использованием комментариев для пояснения логики.
# • ensure_ascii=False: Добавлен параметр ensure_ascii=False в json.dump() для правильной обработки не-ASCII символов (например, русских букв) в выходном JSON файле.
# • Пример использования: Предоставлен полный пример использования, включая создание входного JSON файла, вызов функции process_json, и ожидаемый результат в выходном файле.
# • Обработка не-словарей в списке: Добавлена проверка isinstance(item, dict) для обработки случаев, когда в списке могут быть не словари.
#
# Как это работает:
#
# 1. Чтение JSON: Функция читает содержимое JSON файла, используя json.load(), и преобразует его в список словарей.
# 2. Фильтрация: Проходит по каждому элементу списка. Если элемент является словарем, и содержит ключ key_to_match, и значение этого ключа равно value_to_match, то элемент считается подходящим.
# 3. Извлечение ключей: Для каждого подходящего элемента создается новый словарь, содержащий только те ключи, которые указаны в списке keys_to_extract.
# 4. Запись в JSON: Полученный список отфильтрованных и преобразованных словарей записывается в выходной JSON файл, используя json.dump() с форматированием отступами (indent=4) для читаемости.
#
# Этот код предоставляет надежное и гибкое решение для фильтрации и преобразования JSON данных. Обратите внимание на обработку ошибок и безопасное извлечение ключей. Всегда проверяйте входные данные на соответствие ожидаемому формату, чтобы избежать неожиданных результатов.