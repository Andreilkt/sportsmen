import json

# Пример 1: Простой словарь
data1 = {
    "name": "John Doe",
    "age": 30,
    "city": "New York"
}

json_string1 = json.dumps(data1)
print("Пример 1:")
print(json_string1)
print(type(json_string1))  # Проверяем, что это строка

# Пример 2: Список словарей
data2 = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 40}
]

json_string2 = json.dumps(data2)
print("\nПример 2:")
print(json_string2)

# Пример 3: Использование indent для форматирования
data3 = {
    "name": "Charlie",
    "address": {
        "street": "123 Main St",
        "city": "Anytown",
        "zip": "12345"
    },
    "skills": ["Python", "JavaScript", "SQL"]
}

json_string3 = json.dumps(data3, indent=4)  # Отступ в 4 пробела
print("\nПример 3 (с отступом):")
print(json_string3)

# Пример 4: Использование separators для компактности
data4 = {
    "name": "David",
    "age": 35,
    "city": "Los Angeles"
}

json_string4 = json.dumps(data4, separators=(',', ':')) # Убираем пробелы после запятых и двоеточий
print("\nПример 4 (компактный):")
print(json_string4)

# Пример 5: Сортировка ключей
data5 = {
    "b": 2,
    "a": 1,
    "c": 3
}

json_string5 = json.dumps(data5, sort_keys=True) # Сортировка ключей по алфавиту
print("\nПример 5 (сортировка ключей):")
print(json_string5)

# Пример 6: Преобразование объекта Python в JSON (не напрямую, нужно предварительное преобразование)
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def to_dict(self):
        return self.__dict__  # Преобразуем атрибуты объекта в словарь

person = Person("Eve", 28)

# Важно: Просто так json.dumps() не сможет преобразовать объект.
# Нужно либо реализовать метод to_dict() или использовать кастомный Encoder.

json_string6 = json.dumps(person.to_dict())
print("\nПример 6 (объект Python):")
print(json_string6)

# Пример 7: Работа с Unicode
data7 = {
    "name": "Иван",  # Имя на русском языке
    "city": "Москва"
}

json_string7 = json.dumps(data7, ensure_ascii=False) # Разрешаем использование не-ASCII символов
print("\nПример 7 (Unicode):")
print(json_string7)


# Объяснения к примерам:
#
# • Пример 1: Демонстрирует базовое использование json.dumps() для преобразования простого словаря Python в строку JSON. type(json_string1) показывает, что результат - это строка.
# • Пример 2: Преобразование списка словарей. json.dumps() автоматически обрабатывает списки и вложенные структуры данных.
# • Пример 3: indent=4 добавляет отступы в 4 пробела, делая JSON более читабельным. Это особенно полезно для сложных, вложенных структур.
# • Пример 4: separators=(',', ':') удаляет пробелы после запятых и двоеточий, что делает JSON более компактным. Иногда это полезно, если важен размер передаваемых данных.
# • Пример 5: sort_keys=True сортирует ключи словаря по алфавиту перед преобразованием в JSON. Это может быть полезно для последовательного сравнения JSON-строк.
# • Пример 6: Показывает, как преобразовать экземпляр класса Python в JSON. Важно: json.dumps() не умеет напрямую преобразовывать произвольные объекты Python. Нужно сначала преобразовать их в словарь (или список). В примере используется метод to_dict() класса Person для этого. Существуют и другие способы с использованием кастомных JSONEncoder, но этот способ обычно проще для простых объектов.
# • Пример 7: ensure_ascii=False позволяет корректно обрабатывать символы Unicode (например, русские буквы). Если не указать ensure_ascii=False, не-ASCII символы будут закодированы в виде escape-последовательностей.
#
# Важные моменты:
#
# • json.dumps(obj, ...): Функция json.dumps() принимает объект Python (obj) и преобразует его в JSON-строку.
# • Параметры: json.dumps() имеет множество параметров, которые позволяют настроить процесс преобразования:
#   * indent: Добавляет отступы для улучшения читабельности.
#   * separators: Позволяет настроить разделители между элементами JSON.
#   * sort_keys: Сортирует ключи словаря перед преобразованием.
#   * ensure_ascii: Определяет, следует ли экранировать не-ASCII символы.
#   * default: Указывает функцию, которая будет вызываться для объектов, которые json.dumps не может сериализовать (например, объекты datetime).
# • Обработка ошибок: json.dumps() может выбросить исключение TypeError, если объект не может быть преобразован в JSON.
# • JSONEncoder: Для более сложной сериализации можно использовать кастомные классы, унаследованные от json.JSONEncoder. Это позволяет контролировать процесс преобразования для сложных объектов Python.
#
# Этот расширенный пример охватывает основные случаи использования json.dumps() и предоставляет достаточно информации для начала работы с этой функцией. Помните о необходимости преобразования объектов Python в словари или списки, если они не поддерживаются json.dumps() по умолчанию.